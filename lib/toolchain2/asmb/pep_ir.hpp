#pragma once
#include "./pep_attributes.hpp"
#include "core/compile/source/location.hpp"

namespace pepp::tc::ir {
struct LinearIRVisitor;
struct LinearIR {
  // Every deriving class must have a unique enum entry.
  enum class Type {
    Empty,
    Comment,
    Monadic,
    Dyadic,
    DotAlign,
    DotAnnotate,
    DotBlock,
    DotEquate,
    DotLiteral,
    DotOrg,
    DotSection,
  };

  virtual ~LinearIR() = default;

  // Searches the linked list of attributes for one of the given type.
  // Must override if you inline an attribute into future IR lines.
  virtual const attr::AAttribute *attribute(attr::Type type) const;

  // Override this method if you inline an attribute into future IR lines.
  virtual void insert(std::unique_ptr<attr::AAttribute> attr);

  // Returns either: the number of bytes of object code generated by this line when placed at a specific address, or
  // nullopt. nullopt indicates that the line is not addressable (e.g., a CommentLine) and does not generate object
  // code. Any quint16 return value indicates that the line is addressable, and some number of object code bytes are
  // emitted. 0 /Ais a special case that allows multiple IR lines to share an address, usually in the form of a .BLOCK
  // 0, which is used in macro expansions for handling multiple symbols per line. The default implementation returns
  // nullopt.
  virtual std::optional<quint16> object_size(quint16 base_address) const;

  // We had a pattern of casting base pointers to derived pointers in IR.
  // Derived types have wildly different behaviors even if they have the same API.
  // Instead of using true OO visitor pattern, I've opted for switch(type()) with static casts, which is a poor-mans
  // visitor.
  virtual Type type() const = 0;

  virtual void accept(LinearIRVisitor *visitor) const = 0;

  template <typename Attribute> const Attribute *typed_attribute() const {
    static_assert(std::is_base_of_v<attr::AAttribute, Attribute>, "Attribute must derive from attr::AAttribute");
    return dynamic_cast<const Attribute *>(attribute(Attribute::TYPE));
  }
  template <typename Attribute> bool has_attribute() const {
    static_assert(std::is_base_of_v<attr::AAttribute, Attribute>, "Attribute must derive from attr::AAttribute");
    return attribute(Attribute::TYPE) != nullptr;
  }
  support::LocationInterval source_interval;
  // Head of linked list of additional attributes
  std::unique_ptr<attr::ListNode> extended_attributes;
};

struct EmptyLine : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::Empty;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
};

struct CommentLine : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::Comment;
  explicit CommentLine(attr::Comment c) : comment(std::move(c)) {}
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Comment comment;
};

struct MonadicInstruction : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::Monadic;
  explicit MonadicInstruction(attr::Pep10Mnemonic m) : mnemonic(m) {}
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Pep10Mnemonic mnemonic;
};

struct DyadicInstruction : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::Dyadic;
  DyadicInstruction(attr::Pep10Mnemonic m, attr::Pep10AddrMode am, attr::Argument arg)
      : mnemonic(m), addr_mode(am), argument(arg) {}
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Pep10Mnemonic mnemonic;
  attr::Pep10AddrMode addr_mode;
  attr::Argument argument;
};

enum class DotCommands {
  ALIGN,
  ASCII,
  BLOCK,
  BYTE,
  EQUATE,
  EXPORT,
  IMPORT,
  INPUT,
  ORG,
  OUTPUT,
  SCALL,
  SECTION,
  WORD,
};

struct DotAlign : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotAlign;
  explicit DotAlign(attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Argument argument;
};

struct DotLiteral : public LinearIR { // ASCII, byte, word
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotLiteral;
  enum class Which { ASCII, Byte, Word } which;
  DotLiteral(Which kind, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Argument argument;
};

struct DotBlock : public LinearIR { // Block
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotBlock;
  explicit DotBlock(attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Argument argument;
};

struct DotEquate : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotEquate;
  DotEquate(attr::SymbolDeclaration symbol, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::SymbolDeclaration symbol;
  attr::Argument argument;
};

struct DotSection : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotSection;
  DotSection(attr::Identifier name, attr::SectionFlags flags);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Identifier name;
  attr::SectionFlags flags;
};

struct DotAnnotate : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotAnnotate;
  enum class Which { EXPORT, IMPORT, INPUT, OUTPUT, SCALL } which;
  // Arg must always be an identifier
  DotAnnotate(Which dir, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Argument argument;
};

struct DotOrg : public LinearIR {
  static constexpr LinearIR::Type TYPE = LinearIR::Type::DotOrg;
  enum class Behavior { BURN, ORG } behavior = Behavior::ORG;
  // Arg must always be an number
  DotOrg(Behavior behavior, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  Type type() const override;
  void accept(LinearIRVisitor *visitor) const override;
  attr::Argument argument;
};

struct MacroInvocation : public LinearIR {};

bool defines_symbol(const LinearIR &line);

} // namespace pepp::tc::ir
