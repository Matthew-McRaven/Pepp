#pragma once
#include "./pep_attributes.hpp"
#include "toolchain2/support/source/location.hpp"

namespace pepp::tc::ir {
struct LinearIR {
  virtual ~LinearIR() = default;

  // Searches the linked list of attributes for one of the given type.
  // Must override if you inline an attribute into future IR lines.
  virtual const attr::AAttribute *attribute(attr::Type type) const;

  // Override this method if you inline an attribute into future IR lines.
  virtual void insert(std::unique_ptr<attr::AAttribute> attr);

  // Returns either: the number of bytes of object code generated by this line when placed at a specific address, or
  // nullopt. nullopt indicates that the line is not addressable (e.g., a CommentLine) and does not generate object
  // code. Any quint16 return value indicates that the line is addressable, and some number of object code bytes are
  // emitted. 0 is a special case that allows multiple IR lines to share an address, usually in the form of a .BLOCK 0,
  // which is used in macro expansions for handling multiple symbols per line. The default implementation returns
  // nullopt.
  virtual std::optional<quint16> object_size(quint16 base_address) const;

  template <typename Attribute> const Attribute *typed_attribute() const {
    static_assert(std::is_base_of_v<attr::AAttribute, Attribute>, "Attribute must derive from attr::AAttribute");
    return dynamic_cast<const Attribute *>(attribute(Attribute::TYPE));
  }
  template <typename Attribute> bool has_attribute() const {
    static_assert(std::is_base_of_v<attr::AAttribute, Attribute>, "Attribute must derive from attr::AAttribute");
    return attribute(Attribute::TYPE) != nullptr;
  }
  support::LocationInterval source_interval;
  // Head of linked list of additional attributes
  std::unique_ptr<attr::ListNode> extended_attributes;
};

struct EmptyLine : public LinearIR {};

struct CommentLine : public LinearIR {
  CommentLine(attr::Comment c) : comment(std::move(c)) {}
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  attr::Comment comment;
};

struct MonadicInstruction : public LinearIR {
  MonadicInstruction(attr::Pep10Mnemonic m) : mnemonic(m) {}
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  attr::Pep10Mnemonic mnemonic;
};

struct DyadicInstruction : public LinearIR {
  DyadicInstruction(attr::Pep10Mnemonic m, attr::Pep10AddrMode am, attr::Argument arg)
      : mnemonic(m), addr_mode(am), argument(arg) {}
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  attr::Pep10Mnemonic mnemonic;
  attr::Pep10AddrMode addr_mode;
  attr::Argument argument;
};

enum class DotCommands {
  ALIGN,
  ASCII,
  BLOCK,
  BYTE,
  EQUATE,
  EXPORT,
  IMPORT,
  INPUT,
  ORG,
  OUTPUT,
  SCALL,
  SECTION,
  WORD,
};

struct DotAlign : public LinearIR {
  DotAlign(attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  attr::Argument argument;
};

struct DotLiteral : public LinearIR { // ASCII, byte, word
  enum class Which { ASCII, Byte, Word } which;
  DotLiteral(Which kind, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  attr::Argument argument;
};

struct DotBlock : public LinearIR { // Block
  DotBlock(attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  std::optional<quint16> object_size(quint16 base_address) const override;
  attr::Argument argument;
};

struct DotEquate : public LinearIR {
  DotEquate(attr::SymbolDeclaration symbol, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  attr::SymbolDeclaration symbol;
  attr::Argument argument;
};

struct DotSection : public LinearIR {
  DotSection(attr::Identifier name, attr::SectionFlags flags);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  attr::Identifier name;
  attr::SectionFlags flags;
};

struct DotSCall : public LinearIR {
  DotSCall(attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  attr::Argument argument;
};

struct DotImportExport : public LinearIR {
  enum class Direction { IMPORT, EXPORT } direction;
  DotImportExport(Direction dir, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  attr::Argument argument;
};

struct DotInputOutput : public LinearIR {
  enum class Direction { INPUT, OUTPUT } direction;
  DotInputOutput(Direction dir, attr::Argument arg);
  const attr::AAttribute *attribute(attr::Type type) const override;
  void insert(std::unique_ptr<attr::AAttribute> attr) override;
  attr::Argument argument;
};

struct DotOrg : public LinearIR {
  enum class Behavior { BURN, ORG } behavior = Behavior::ORG;
  attr::Argument argument;
};

struct MacroInvocation : public LinearIR {};

bool defines_symbol(const LinearIR &line);

} // namespace pepp::tc::ir
